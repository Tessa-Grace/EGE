# task 1
from itertools import permutations

matrix = 'все строки из матрицы'.split()
graph = 'все ребра из графа'.split()

print(*range(1, 8)) #количество столбцов в матрице
for i in permutations('названия вершин'):
   if all(str(i.index(x) + 1) in matrix[i.index(y)] for x, y in graph):
       print(*i)
#____________________________________

# task 2
Всегда следи за порядком выполнения операций!

Порядок выполнения операций в алгебре логики:
1. Инверсия (A, ¬A, (not A))
2. Конъюнкция (A∧B, A∙B, A and B)
3. Дизъюнкция (A∨B, A+B, A or B)
4. Импликация (A→B, A<=B)
5. Эквивалентность (A≡B, A==B)

Порядок выполнения операция в Python:
1. Базовые логические операции (<, >, <=, >=, ==,  !=)
2. Инверсия (A, ¬A, (not A))
3. Конъюнкция (A∧B, A∙B, A and B)
4. Дизъюнкция (A∨B, A+B, A or B)

Обычный код:
print('x y z w')
for x in 0,1:
  for y in 0,1:
       for z in 0,1:
           for w in 0,1:
               f = логическое выражение
               if f: # если нужны истинные значения
                   print(x,y,z,w)
               if not f: # если нужны ложные значения
                   print(x,y,z,w)

Крутой код:
from itertools import permutations, product
def f(x, y, z, w):
   return # логическое выражение
# кол-во переменных и repeat зависит
# от кол-ва пустых ячеек в таблице
for a1, a2, a3 in product([0, 1], repeat=3):
   table = [переписываем все строки из таблицы в кортежи]
   if len(table) == len(set(table)):
       for p in permutations('xyzw'):
           u = [f(**dict(zip(p, t))) for t in table] == [столбец F]
           if u:
               print(*p)
#__________________________________

# task 3
= ВПР(что мы ищем?; где мы ищем?; в каком столбце ответ; 0)

На сколько увеличилось кол-во товаров: (Поступление - Продажа)

Прибыль: (Продажа - Покупка)
Выручка: (Продажа)

Если просят объем, обязательно переносим объем каждой единицы товара!!!

#__________________________________

# task 4
Прямое условие Фано: Никакое кодовое слово не может быть началом другого кодового слова.
Дерево строится по принципу - дублируем предка, приписываем к нему цифру в конце

Обратное условие Фано: никакой код не был окончанием другого (более длинного) кода.
Дерево строится по принципу - дублируем предка, приписываем к нему цифру в начале

Внимательно читай, нужно ли использовать весь алфавит! Если нужно, то оставь одну ветку!
#__________________________________

# task 5
Всегда следи за границами начальных значений!
1. Если по условию n натуральное
    range(1, 10_000)
2. Если по условию n неотрицательное
    range(0, 10_000)
3. Если по условию n > 10
    range(11, 10_000)

Стандартные функции:
1. Представление числа N в двоичной системе
    bin(N)[2:]
2. Представление числа N в восьмеричной системе
    oct(N)[2:]
3. Представление числа N в шестнадцатеричной системе
    hex(N)[2:]
4. Перевод числа N (в формате строки) в 10 из sys системы счисления
    int(N, sys)

Функция для перевода (2 ≤sys ≤ 36)
from string import digits, ascii_lowercase
def convert(num, sys):
   alph = digits + ascii_lowercase
   res = ''
   while num:
       res += alph[num % sys]
       num //= sys
   return res[::-1]

1. Сумма цифр строки R в двоичной системе
    R.count('1')
2. Сумма цифр строки R
    sum(map(int, R))
3. Количество четных цифр
    r = hex(15623)[2:]
    sum([1 for i in r if int(i, 16) % 2 == 0])

Срезы:
R = R[:len(R)//2] + 'что-то' + R[len(R)//2:] – вставка в середину строки
R = R + R[-3:] – приписать последние три символа в конец строки
#__________________________________

# task 6
Следи за положением хвоста и головы черепахи в начальный момент времени. Это пишут в условии задания

Что надо найти:
1. Пересечение - Только тот кусочек, где они наложились друг на друга
2. Объединение - Обе фигуры вместе

Лайфхаки:
1. Точки на линии учитывать не следует - шаг черепахи минус одни * шаг черепахи минус одни
2. Точки на линии учитывать следует - шаг черепахи плюс один * шаг черепахи плюс один
3. Периметр - шаг черепахи * шаг черепахи
#__________________________________

# task 7
Изображение:
V= h × w × i , где
h × w - высота × ширина изображения кол-во пикселей
i - вес одного пикселя в битах, i = log2(N) , где
N - кол-во цветов, N = 2 ** i

Звуковой файл:
V = k × i × t × η, где
k - кол-во каналов моно- 1, стерео- 2, квадро- 4
i - глубина кодирования в битах / разрешение
t - длительность записи в секундах
η - частота дискретизации в герцах

Объем через скорость передачи данных:
V = q × t, где
q - скорость передачи в битах в секунду
t - время передачи данных в секундах

Округление:
Если известен вес файла и необходимо найти одну из величин, всегда после деления округляем в меньшую сторону,
иначе не получится поместить файл в выделенную память.
Для самопроверки, если сомневаешься в какую сторону округлять, рассмотри оба варианта и проверь,
в каком из случаев твой файл помещается в выделенный объем памяти.
Вес файла не обязан с точностью до бита совпадать с объемом выделенной памяти, он может быть
(и зачастую бывает) меньше выделенного объема.

#__________________________________

# task 8

Все возможные комбинации определенной длины:
from itertools import product
alph = '1234' # алфавит из условия задания
length = 5 # длина комбинаций из условия
for i in product(alph, repeat=length):
   i = ''.join(i)

Все возможные перестановки:
from itertools import permutations
alph = '1234' # алфавит из условия задания
for i in set(permutations(alph)):
   i = ''.join(i)

Тип заданий с пронумерованным списком комбинаций:
from itertools import product
alph = 'ДВИАЬ' # алфавит из условия
# если слова в алфавитном порядке
alph = sorted(alph)
# если слова в обратном алфавитном порядке
alph = sorted(alph, reverse=True)
for pos, val in enumerate(product(alph, repeat=5), start=1):
   val = ''.join(val)

1. Если работаешь с формированием чисел, проверь, не стоит ли ноль в начале
	if i[0] != '0':
2. Проверка, что символ встречается в комбинации
	if 'A' in i:
3. Проверка, что символ не встречается в комбинации
	if 'A' not in i:
4. Проверка, что символ встречается в комбинации 3 раза
	if i.count('A') == 3:
5. Проверка, что четность символов чередуется
	u = ''.join([str(int(i) % 2) for i in val])
	if '11' not in u and '00' not in u:
6. Проверка, что есть не менее трех цифр с числовым значением более 9
    u = len([i for i in val if i not in '0123456789'])
    if u >= 3:
7. Кол-во пар одинаковых символов
    sum([val[i:i+2] == 'AA' for i in range(len(val) - 1)])
#__________________________________

# task 9
Полезные формулы Excel:
=СУММЕСЛИ()
=СЧЁТЕСЛИ()
=МОДА()
=НАИМЕНЬШИЙ()
=НАИБОЛЬШИЙ()

Начало решения кодом(считывание данных из файла):
with open('input.txt') as file:
    nums = [list(map(int, i.split())) for i in file]

Полезные функции:
1. Подсчет повторяющихся чисел
	def f(nums):
	   cnt = [nums.count(i) for i in nums]
	   return # условие
2. Поиск всех повторяющихся/неповторяющихся чисел
	def f(nums):
	   nepov = [i for i in nums if nums.count(i) == 1]
	   pov = [i for i in nums if nums.count(i) != 1]
3. Все числа различны
	def f(nums):
	   return len(nums) == len(set(nums))
4. 4 числа можно разбить на две пары с равными суммами
	def f(nums):
	   return max(nums) + min(nums) == sum(nums) - max(nums)- min(nums)
5. Разность максимального и минимального числа кратна разности оставшейся пары чисел
	def f(nums):
	   nums = sorted(nums)
	   return nums[-2] - nums[1] != 0 and (nums[-1] - nums[0]) % (nums[-2] - nums[1]) == 0


Что попросят дать в ответ:

1. Количество строк
	cnt = 0
	for i in arr:
	   if f1(i) and f2(i):
	       cnt += 1
	print(cnt)

2. Поиск наименьшего номера строки
	for pos, val in enumerate(arr, start=1):
	   if f1(val) and f2(val):
	       print(pos)
	       break

3. Поиск наибольшего номера строки
	for pos, val in enumerate(arr, start=1)[::-1]:
	   if f1(val) and f2(val):
	       print(pos)
	       break

4. Сумма элементов строки
	for i in arr:
	   if f1(i) and f2(i):
	       print(sum(i))
	       break
#__________________________________

# task 10
Буквы бывают:
Строчная = Маленькая
Прописная = Заглавная = Большая

Дефис следует всегда заменять на пустоту (порусски)

Нужные главы выносим в отдельный файл
#__________________________________

# task 11
Всегда внимательно следи за тем, какова мощность исходного алфавита!
Самая частая ошибка - забыть про десятичные цифры

Варианты описания алфавита:
1. Буквы латинского алфавита, регистр не важен - 26 символов
2. Буквы латинского алфавита, регистр имеет значение - 52 символа
3. Десятичные цифры и K букв специального алфавита - K + 10 символов

Формула:
I = L × i, где
L - длина пароля / идентификатора
i - вес одного символа в битах, i = log2(N), где
N - мощность алфавита (кол-во символов)
При нахождении веса одного символа всегда округляем в большую сторону


Варианты формулировки (кодирование символов):
1. При этом используется посимвольное кодирование идентификаторов,
все символы кодируются одинаковым и минимально возможным количеством бит.
    При такой формулировке работаем как обычно. Находим i = log2(N), округляем в большую сторону.
2. При этом используется посимвольное кодирование идентификаторов,
все символы кодируются одинаковым и минимально возможным количеством байт.
    При такой формулировке находим i = log2(N), округляем в большую сторону.
    Далее делим на 8 и снова округляем в большую сторону.

Варианты формулировки (кодирование идентификатора):
1. В базе данных для хранения каждого идентификатора отведено одинаковое и
    минимально возможное целое число байт.
    При такой формулировке находим I = L × i и делим на 8. Округляем всегда в большую сторону.


Варианты вопросов заданий:
1. Определить объем памяти для хранения X пользователей
    I × X - важно помнить, что I уже в байтах, поэтому для перевода к Кб делим только на 1024
2. Определите длину пароля, если известна мощность алфавита и вес одного пароля (обратная задача)
    L = I / i, в данном случае округляем в меньшую сторону, чтоб уместиться в выделенную память
3. Определите мощность алфавита, если известны длина и вес одного пароля (обратная задача)
    i = I / L, N = 2 ** i, округляем в меньшую сторону, иначе не уместимся в выделенную память

    Если просят максимальную мощность алфавита - N = 2 ** i
    Если просят минимальную мощность алфавита -  N = 2 ** (i - 1) + 1
#__________________________________

# task 12
Всегда следи за границами начальных значений!
Если по условию (3 < n < 10 000), то запускай range(4, 10_000)

Варианты функции заменить:
1. Заменяет первое слева вхождение
    st = st.replace('old', 'new', 1)
2. Заменяет первые N вхождений слева
    st = st.replace('old', 'new', N)
3. Заменяет все вхождения
    st = st.replace('old', 'new')
4. Заменяет первое справа вхождение (если символов несколько, переворачиваем заменяемые строки)
    st = st[::-1].replace('dlo', 'wen', 1)[::-1]

Полезные алгоритмы:
1. Сумма числовых значений строки (сумма цифр числа)
    summ = sum(map(int, st))
2. Если после работы алгоритма в строке есть нечисловые значения, лучше от них избавиться
    st = st.replace('>', '')
#__________________________________

# task 13
Основные команды:
1. ip = ip_address() - переводит текстовое представление ip-адреса в объект класса ipaddress
2. net = ip_network('ip/mask') - создает сеть / создает все адреса в текущей сети с определенной маской
3. net.network_address - адрес сети
4. net.broadcast_address - широковещательный адрес сети
5. net.netmask() - маска сети
6. net.hosts() - все узлы сети
7. net.num_addresses - кол-во адресов в сети (узлы + адрес сети + широковещательный)

Перевод в двоичную систему:
i = f'{int(ip):032b}'

Получение левых двух байтов и правых двух байтов:
i = f'{int(ip):032b}'
left = i[:16]
right = i[16:]

Диапазон для поиска маски - range(10, 31)

Дано по условию:
1. Сеть + маска
    Строим саму сеть, что-то делаем с узлами
2. Сеть + узел:
    В цикле перебираем варианты маски
3. Два узла
    Обязательно убедиться, что ip является УЗЛОМ!!!, а не адресом сети или широковещательным
    ip != net.network_address() and ip != net.broadcast_address()
    ip not in (net.network_address(), net.broadcast_address())
    ip in net.hosts()

#__________________________________

# task 14
Термины:
1. Незначащие нули - нули стоящие в начале числа и не влияющие на его числовое значение
    1 == 01 == 001 == 0001 - все нули незначащие, мы получаем одно и то же число
2. Значащие нули - любой ноль, которые стоит где-то внутри числа
    10, 1024, 5807, 8000 - все нули значащие

Если неизвестная переменная стоит на нулевой позиции, алфавит следует брать с единицы


Тип 1 - выражение без неизвестных (номер 4619):

def convert(num, sys):
    res = ''
    while num:
        res += str(num % sys)
        num //= sys
    return res[::-1]

num = 343**1515 - 6*49**1520 + 5*49**1510 - 3*7**1530 - 1550
num_7 = convert(num, 7)
print(num_7.count('0'))

Тип 2 - выражение с одной неизвестной  (2 ≤sys ≤ 36):

from string import digits, ascii_uppercase

alph = digits + ascii_uppercase

for x in alph[:23]:
    num1 = int(f'7{x}38596', 23)
    num2 = int(f'14{x}36', 23)
    num3 = int(f'61{x}7', 23)
    num = num1 + num2 + num3
    if num % 22 == 0:
        print(x, num // 22)

Тип 3 - выражение с одной неизвестной  (sys > 36):

for x in range(1, 150):
    num1 = 5*150**4 + 1*150**3 + x*150**2 + 2*150 + 9
    num2 = x*150**3 + 2*150 + 3
    num = num1 + num2
    if num % 149 == 0:
        print(num // 149)

Тип 4 - выражение с неизвестным числом

def convert(num, sys):
    res = ''
    while num:
        res += str(num % sys)
        num //= sys
    return res[::-1]

for x in range(1, 2031):
    num = 6**260 + 6**160 + 6**60 - x
    num_6 = convert(num, 6)
    if num_6.count('0') == 202:
        print(x)
#__________________________________

# task 15
Всегда следи за допустимыми значениями
    натуральное A - range(1, 10_000)
    неотрицательное A - range(0, 10_000)
    целое A - range(-10_000, 10_000)

При формировании числовой прямой для контроля выколотых точек:
arr = [i + eps for i in range(20, 60) for eps in [0, 0.1, 0.9]]
#__________________________________

# task 16
Полезные функции:
1. Увеличение глубины рекурсии, если выдает ошибку maximum recursion depth
    from sys import setrecursionlimit
    setrecursionlimit(10_000)
2. Кэширование промежуточных результатов, если программа слишком долго думает
    from functools import lru_cache
    @lru_cache(None)
#__________________________________

# task 17
Важно помнить!
Интервал значений из условия задания:
1. Натуральные числа
Решаем как обычно.

2. Числа по модулю не превышающие 10 000 / числа от -10 000 до 10 000
Всегда берем по модулю при проверке:
1. Кратность какому-то числу
    abs(i) % 7 == 0 # число кратное 7
2. Кол-во цифр в числе
    len(str(abs(i))) == 2 # двузначное число
#__________________________________

# task 18
Следи за тем:
1. в каких ячейках нужно выбирать конечное число
2. присутствуют ли мертвые зоны
3. в каком порядке необходимо давать ответы
#__________________________________

# task 19-21
1. Известно, что Ваня выиграл своим первым ходом после неудачного хода Пети
Если противник неудачник, то нам не важно как он походит.
Главное, что он совершит неудачный ход и приведет нас к победе. В коде в последней строке функции пишем
    return any(h)

2. Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом
Мы должны победить при любом ходе противника.
Т.е. он выстраивает стратегию и не будет совершать ходы, которые приведут его к проигрышу.
В коде в последней строке функции пишем
    return any(h) if (s-1) % 2 == 0 else all(h)

Условия завершения игры:
1. Петя победил первым ходом
    print([s for s in range(1, 69) if f(s, 1)])
2. Ваня победил первым ходом
    print([s for s in range(1, 69) if f(s, 2)])
3. Петя победи вторым или первым ходом, но не только первым
    print([s for s in range(1, 69) if f(s, 3) and not f(s, 1)])
4. Ваня победил вторым или первым  ходом, но не только первым
    print([s for s in range(1, 69) if f(s, 4) and not f(s, 2)])
5. Петя победил третьим, вторым или первым  ходом, но не только первым или только вторым
    print([s for s in range(1, 69) if f(s, 5) and not f(s, 3)])
6. Ваня победил третьим, вторым или первым  ходом, но не только первым или только вторым
    print([s for s in range(1, 69) if f(s, 6) and not f(s, 4)])

Общий алгоритм кодом:
def f(x, s): # x - кол-во камней, s - кол-во ходов до конца игры
   if x <= 12: # условие завершения игры
       return s % 2 == 0 # возвращаем того, кто сделал последний ход
   if s == 0: # если ходы кончились, игра завершается с проигрышем
       return False
   h = [f(x // 3, s - 1), f(x - 12, s - 1)] # список всех возможных действий
   return any(h) if (s - 1) % 2 == 0 else all(h)
# Ответ для каждого задания
print('19) ', [s for s in range(1000, 13, -1) if f(s, 2)])
print('20) ', [s for s in range(1000, 13, -1) if f(s, 3) and not f(s, 1)])
print('21) ', [s for s in range(1000, 13, -1) if f(s, 4) and not f(s, 2)])

Пример на две кучи + неудачный ход:
def f_19(x, y, s):
    if x + y >= 123: return s % 2 == 0
    if s == 0: return False
    h = [f_19(x + 1, y, s - 1), f_19(x * 2, y, s - 1), \
         f_19(x, y + 1, s - 1), f_19(x, y * 2, s - 1)]
    return any(h)

def f(x, y, s):
    if x + y >= 123: return s % 2 == 0
    if s == 0: return False
    h = [f(x + 1, y, s - 1), f(x * 2, y, s - 1), f(x, y + 1, s - 1), f(x, y * 2, s - 1)]
    return any(h) if (s - 1) % 2 == 0 else all(h)

print('19)', [s for s in range(1, 110) if f_19(s, 13, 2)])
print('20)', [s for s in range(1, 110) if f(s, 13, 3) and not f(s, 13, 1)])
print('21)', [s for s in range(1, 110) if f(s, 13, 4) and not f(s, 13, 2)])
#__________________________________

# task 22
В последнее время в основном существуют 3 типа задания 22, которые отличаются в следующих формулировках:

1. Все независимые друг от друга процессы могут выполняться параллельно;
    Двигаем диаграмму как хотим
2. Все независимые друг от друга процессы могут выполняться параллельно, а время завершения работы каждого процесса минимально;
    Двигаем не дальше самого последнего процесса
3. Все независимые друг от друга процессы могут выполняться параллельно, а время завершения работы всех процессов минимально
    Никак не двигаем
#__________________________________

# task 23
Варианты промежуточных точек:
1. Траектория не должна проходить через число A
    В проверку на неподходящую траекторию добавляем запись
    if x > y or x == A: return 0
2. Траектория должна проходить через число A
    В самом конце при вызове функции для дачи ответа добавляем запись
    print(f(1, A) * f(A, 20)), где 1 начальная точка, 20 - конечная


Варианты действий в проверке на неподходящую траекторию:
1. На увеличение числа
    if x > y: return 0
2. На уменьшение числа
    if x < y: return 0

Пример 1:
Исполнитель преобразует число на экране. У исполнителя есть три команды, которые обозначены латинскими буквами:
А. Вычесть 1
В. Вычесть 3
С. Найти целую часть от деления на 2
Программа для исполнителя — это последовательность команд.
Сколько существует программ, для которых при исходном числе 19 результатом является число 3, при этом траектория вычислений не содержит числа 7 и содержит 10?
Решение 1:
    def f(x, y):
       if x == y: return 1
       if x < y or x == 7: return 0
       return f(x - 1, y) + f(x - 3, y) + f(x // 2, y)
    print(f(19, 10) * f(10, 3))
Пример 2:
Исполнитель преобразует число на экране. У исполнителя есть три команды, которым присвоены номера:
A. Прибавить 2
B. Прибавить 3
C. Умножить на 2
Программа для исполнителя – это последовательность команд.
Сколько существует программ, для которых при исходном числе 3 результатом является число 25, и при этом траектория вычислений содержит число 10 и не содержит 17?
Решение 2:
    def f(x, y):
       if x == y: return 1
       if x > y or x == 17: return 0
       return f(x + 2, y) + f(x + 3, y) + f(x * 2, y)
    print(f(3, 10) * f(10, 25))
#__________________________________

# task 24







#__________________________________

# task 25
Полезные алгоритмы:
1. Проверка числа на простоту
    def is_prime(num):
       if num < 2: return False
       for i in range(2, int(num ** 0.5) + 1):
           if num % i == 0:
               return False
       return True
2. Поиск всех делителей числа
    def delit(num):
       ans = []
       for i in range(2, int(num ** 0.5) + 1):
           if num % i == 0:
               ans.append(i)
               ans.append(num // i)
       ans = set(ans)

Проверка числа на соответствие маске:
    from fnmatch import fnmatch
    fnmatch('исходная строка', 'маска')
Результат работы функции - True или False
Обозначения в маске:
    ? - один любой символ
    * - любая последовательность
    [0-9] - одна любая цифра
    [a-z] - одна любая буква латинского алфавита
    [0-9a-z] - одна цифра или одна буква латинского алфавита
    [1, 3, a] - один  любой символ из указанного набора
Примеры:
    fnmatch('1234', '[0-9][0-9][0-9][0-9]') -> True
    fnmatch('1234', '[0-9][0-9][0-9][0-3]') -> False
    fnmatch('1234', '[1, 2][2, 4][3, 6][4, 8]') -> True
    fnmatch('1234', '[1, 2][2, 4][3, 6][5, 8]') -> False
    fnmatch('1234', '?234') -> True
    fnmatch('1234', '?1234') -> False
    fnmatch('1234', '*234') -> True
    fnmatch('1234', '*1234') -> True
    fnmatch('1234', '*') -> True
    fnmatch('aboba', '[a][b][o][b][a]') -> True
    fnmatch('aboba', '[a][b][o][b][o]') -> False
    fnmatch('aboba', '[a][b][o][b][o, a]') -> True
    fnmatch('abob0', '[a][b][o][b][0-9a-z]') -> True
    fnmatch('abobz', '[a][b][o][b][0-9a-y]') -> False

Определение границ поиска чисел:
Алгоритм:
Левую границу перебора устанавливаем по формуле:
    N - N % D, где N - минимальное число, подходящее под маску (составляем вручную)
    D - число, на которое должны делиться числа из условия (также выставляем как шаг цикла)

Правую границу берем как максимальное число из условия

Составление минимального числа, подходящего маске:
    ? заменяем на 0
    * удаляем

Пример:
Среди натуральных чисел, не превышающих 10**10, найдите все числа, соответствующие маске 1*2322?2,
делящиеся на 2024 без остатка.
Решение:
    for i in range(1232202 - 1232202 % 2023, 10 ** 10, 2024):
#__________________________________

# task 26






#__________________________________

# task 27
